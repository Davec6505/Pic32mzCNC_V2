@startuml Motion_Buffer_Working
!theme cerulean
title Motion Buffer - Ring Buffer Architecture

' ============================================================================
' SIMPLE BUFFER VISUALIZATION
' ============================================================================
package "Ring Buffer (16 blocks)" {
  rectangle "Index [0]" as B0
  rectangle "Index [1]" as B1
  rectangle "Index [2]\nBLOCK A\n← TAIL" as B2 #LightGreen
  rectangle "Index [3]\nBLOCK B" as B3 #LightGreen
  rectangle "Index [4]\nBLOCK C" as B4 #LightGreen
  rectangle "Index [5]\n← HEAD\n(next write)" as B5 #LightCoral
  rectangle "Index [6-15]\n..." as B6
  
  B0 -[hidden]down-> B1
  B1 -[hidden]down-> B2
  B2 -[hidden]down-> B3
  B3 -[hidden]down-> B4
  B4 -[hidden]down-> B5
  B5 -[hidden]down-> B6
}

note right of B2
  **TAIL** = read position
  Next block to execute
  Advances on GetNext()
end note

note right of B5
  **HEAD** = write position
  Next available slot
  Advances on Add()
end note

' ============================================================================
' BUFFER PROPERTIES
' ============================================================================
package "Ring Buffer Properties" {
  rectangle "Size: 16 blocks" as Size
  rectangle "Each block: ~120 bytes" as BlockSize
  rectangle "Total: ~2KB RAM" as Total
  
  Size -[hidden]down-> BlockSize
  BlockSize -[hidden]down-> Total
}

note right of Size
  **Empty**: head == tail
  **Full**: (head + 1) % 16 == tail
  **Count**: (head - tail + 16) % 16
end note

' ============================================================================
' DATA FLOW
' ============================================================================
rectangle "Parser" as Parser
rectangle "MotionBuffer_Add()" as Add
rectangle "Ring Buffer" as Buffer
rectangle "MotionBuffer_GetNext()" as Get
rectangle "MultiAxis_Control" as Execute

Parser --> Add : parsed_move_t
Add --> Buffer : Store block
Buffer --> Get : Read block
Get --> Execute : motion_block_t

note bottom of Add
  **Add Operation**:
  1. Check if buffer full
  2. Convert mm → steps
  3. Calculate junction velocity
  4. Store at buffer[head]
  5. head = (head + 1) % 16
end note

note bottom of Get
  **GetNext Operation**:
  1. Check if empty/paused
  2. Copy buffer[tail]
  3. tail = (tail + 1) % 16
  4. Return block
end note

' ============================================================================
' API OPERATIONS
' ============================================================================
package "Motion Buffer API" {
  rectangle "MotionBuffer_Add()" as API_Add
  rectangle "MotionBuffer_GetNext()" as API_Get
  rectangle "MotionBuffer_Pause()" as API_Pause
  rectangle "MotionBuffer_Resume()" as API_Resume
  rectangle "MotionBuffer_Clear()" as API_Clear
  rectangle "MotionBuffer_RecalculateAll()" as API_Recalc
}

note right of API_Add
  Enqueue new move
end note

note right of API_Get
  Dequeue next move
end note

note right of API_Pause
  Feed hold (!)
end note

note right of API_Resume
  Cycle start (~)
end note

note right of API_Clear
  Emergency stop (^X)
end note

note right of API_Recalc
  Look-ahead planning (TODO)
end note

' ============================================================================
' LEGEND
' ============================================================================
legend bottom
  **Color Legend**:
  * <back:lightgreen>Green</back> = Occupied blocks (has data)
  * <back:lightcoral>Coral</back> = HEAD pointer (next write)
  * <back:white>White</back> = Empty slots
  
  **Performance**:
  * Add: O(1) constant time
  * GetNext: O(1) constant time
  * Modulo arithmetic for wraparound
  
  **GRBL Integration**:
  * When FULL: Don't send "ok" (flow control)
  * Real-time commands bypass buffer
  * Planning threshold: 4 blocks
end legend

@enduml
